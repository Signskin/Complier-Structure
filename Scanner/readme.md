此为Scanner之主分支.
其在Scanner_Submitted基础上添加了:
1. 扩充ItemDFA.
    1. 修正了有符号整数字面量只支持一个数位之问题.
    1. 加入对浮点数字面量之支持.
    1. 加入对逻辑运算符AND及OR之支持.
    1. 加入对字符串字面量之支持.
2. 扩充实现.
    2. 加入对跨行代码之支持,即行尾反斜杠字符.
    2. 在预处理阶段,即词法分析前,检查字符串引号闭合情况.
对浮点数字面量、字符串字面量处理之预期结果为如同C++标准中对他们规定那样,但实现或有差异.

目前显式不支援之语法有:
1. 用户定义之字面量前后缀
2. 原始字符串字面量
3. 整数字面量之进制标记

本程序实现之功能序列如下:
1. 从Format.txt读取词法分析框架.
2. 从Source.txt读取源代码.
3. 按1.中读入的框架,对2.中读入的源代码进行词法分析.
4. 向Tokens.txt写入词法分析结果.

## 词法分析框架
由至少三个段组成的文件,段名在文件第一行指定,必须包含symbol,state,transfer段.
段名指定格式为 `define symbol state transfer 其余可选段名`,以空格隔开

每个段以段名开头,以end 段名结束,此二指令必须在单独一行.

段可以为空,但必须定义至少一次,多次定义会按定义顺序合并.

### symbol段
每行包含一个不含有空格的标识符名,用于定义一个词法单元种类.在此标识符后,允许添加可选的注释.

简单来说,对symbol段,每行接入一个输入流,流中读到的第一个非空且不含空白的字符串作为新定义的词法单元种类名,行的其余部分作为注释.

对同一词法单元种类名定义多次不会影响结果,但会保存多个种类名副本.

### state段
每行是以下三种格式之一,用于定义ItemDFA的状态.
1. begin 状态名
2. accept 状态名 词法单元种类名/可选段名
3. 状态名
分别对应了ItemDFA的起始状态,接受状态(及当前最长前缀所属之词法单元)和中间状态.
若在accept中指定的是可选段名,则作附加处理,能否正确处理及处理结果视乎附加段.
状态名不能包含空白,否则是错误行为,但程序不给出诊断.
定义多个相同的状态名是错误行为,但程序不给出诊断.

### transfer
每行是以下格式

`当前状态 目的状态 正则表达式`

正则表达式包括了该行除了当前状态及目的状态余下部分去除行尾空白部分之全部内容.

意义是定义了ItemDFA之一个转移弧.

该DFA模拟执行时每次只会拉取一个字符读入以匹配正则表达式,因而在正则表达式中包含多字符模式是正确但无效之行为.

多次定义当前状态和目的状态相同的转移是正确行为,其相当于在正则表达式中作或.

### 剩余段
目的是用于附加处理,即用枚举之方式处理可能产生混淆之情形(如关键字与用户定义标识符),每行是以下格式

`词法单元种类名 正则表达式/空`

处理过程为,按定义顺序使用正则表达式匹配当前最大前缀,若成功则返回对应的词法单元种类名,若失败则进入下一行,遇到第一个空正则表达式时立即返回对应的词法单元种类名.

不按上述规定书写的Format.txt行为未定义,可能正确执行也可能抛出错误并终止.

## ItemDFA
含义同一般的ItemDFA.

采用最大匹配,或按C++标准规定之称呼最大吞噬.

当遇到以下任何一项时匹配失败:
1. 在模拟DFA时遇到了未定义之状态名,可选段名. 此时抛出异常,默认未捕获,因而会终止程序.
2. 没有任何转移可用. 此时直接放弃当前最大前缀,如同其不存在,输出异常消息并分析其后的内容.

## 其他可能异常行为
1. 在某一行中字符串未闭合且未指明逻辑行合并. 此时输出错误信息,终止程序.
2. 在任何一个文件中出现了非ASCII字符,或按C++中char字符无法承载之内容. 此时行为未定义,其行为取决于C++实现对此之行为.
3. 可能的I/O错误. 此时输出错误信息,终止程序.
